----- Start of file: ./package.json -----
{
  "name": "vite-template-redux",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "start": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest run",
    "format": "prettier --write .",
    "lint": "eslint .",
    "lint:fix": "eslint --fix .",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.0",
    "@mui/material": "^6.4.3",
    "@reduxjs/toolkit": "^2.0.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^9.1.0",
    "react-router-dom": "^7.1.5"
  },
  "devDependencies": {
    "@testing-library/dom": "^9.3.4",
    "@testing-library/jest-dom": "^6.2.0",
    "@testing-library/react": "^14.1.2",
    "@testing-library/user-event": "^14.5.2",
    "@types/react": "^18.2.47",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.56.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-config-react-app": "^7.0.1",
    "eslint-plugin-prettier": "^5.1.3",
    "jsdom": "^23.2.0",
    "prettier": "^3.2.1",
    "typescript": "^5.3.3",
    "vite": "^5.0.11",
    "vitest": "^1.2.0"
  }
}
----- End of file: ./package.json -----

----- Start of file: ./src/App.css -----
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-float infinite 3s ease-in-out;
  }
}

.App-header {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
}

.App-link {
  color: rgb(112, 76, 182);
}

@keyframes App-logo-float {
  0% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(10px);
  }
  100% {
    transform: translateY(0px);
  }
}
----- End of file: ./src/App.css -----

----- Start of file: ./src/App.tsx -----
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import PokemonList from './features/pokemon/PokemonList';
import PokemonDetail from './features/pokemon/PokemonDetail';
import { Container } from '@mui/material';

const App: React.FC = () => {
  return (
    <Router>
      <Container maxWidth="lg">
        <Routes>
          <Route path="/" element={<Navigate to="/items" />} />
          <Route path="/items" element={<PokemonList />} />
          <Route path="/item/:id" element={<PokemonDetail />} />
        </Routes>
      </Container>
    </Router>
  );
};

export default App;
----- End of file: ./src/App.tsx -----

----- Start of file: ./src/app/hooks.ts -----
// This file serves as a central hub for re-exporting pre-typed Redux hooks.
// These imports are restricted elsewhere to ensure consistent
// usage of typed hooks throughout the application.
// We disable the ESLint rule here because this is the designated place
// for importing and re-exporting the typed versions of hooks.
/* eslint-disable @typescript-eslint/no-restricted-imports */
import { useDispatch, useSelector } from "react-redux"
import type { AppDispatch, RootState } from "./store"

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()
----- End of file: ./src/app/hooks.ts -----

----- Start of file: ./src/app/store.ts -----
import { configureStore } from '@reduxjs/toolkit';
import pokemonReducer from '../features/pokemon/pokemonSlice';

export const store = configureStore({
  reducer: {
    pokemon: pokemonReducer
  }
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
----- End of file: ./src/app/store.ts -----

----- Start of file: ./src/features/pokemon/PokemonDetail.tsx -----
import { useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../../app/hooks';
import type { RootState, AppDispatch } from '../../app/store';
import { fetchPokemonDetail } from './pokemonSlice';
import { useParams } from 'react-router-dom';
import {
    Card,
    CardContent,
    CardMedia,
    Typography,
    CircularProgress,
    Paper,
    Box
} from '@mui/material';

const PokemonDetail: React.FC = () => {
    const { id } = useParams<{ id: string }>();
    const pokemonId = Number(id);
    const dispatch = useAppDispatch<AppDispatch>();
    const pokemon = useAppSelector((state: RootState) => state.pokemon.detail[pokemonId]);
    const detailStatus = useAppSelector((state: RootState) => state.pokemon.detailStatus[pokemonId]);
    const detailError = useAppSelector((state: RootState) => state.pokemon.detailError[pokemonId]);

    useEffect(() => {
        if (!pokemon && detailStatus !== 'loading') {
            dispatch(fetchPokemonDetail(pokemonId));
        }
    }, [dispatch, pokemon, pokemonId, detailStatus]);

    if (detailStatus === 'loading' || !pokemon) {
        return (
            <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
                <CircularProgress />
            </Box>
        );
    }

    if (detailStatus === 'failed') {
        return <Typography color="error">{detailError}</Typography>;
    }

    return (
        <Paper sx={{ maxWidth: 600, margin: 'auto', mt: 4 }}>
            <Card>
                <CardMedia component="img" height="300" image={pokemon.sprite_url} alt={pokemon.name} />
                <CardContent>
                    <Typography variant="h5">{pokemon.name}</Typography>
                    <Typography variant="body1">Height: {pokemon.height}</Typography>
                    <Typography variant="body1">Weight: {pokemon.weight}</Typography>
                    <Typography variant="subtitle1" mt={2}>
                        Stats:
                    </Typography>
                    {pokemon.stats.map((stat, index) => (
                        <Typography key={index} variant="body2">
                            {stat.stat_name}: {stat.base_stat} (effort: {stat.effort})
                        </Typography>
                    ))}
                    <Typography variant="subtitle1" mt={2}>
                        Types:
                    </Typography>
                    <Typography variant="body2">{pokemon.types.join(', ')}</Typography>
                </CardContent>
            </Card>
        </Paper>
    );
};

export default PokemonDetail;
----- End of file: ./src/features/pokemon/PokemonDetail.tsx -----

----- Start of file: ./src/features/pokemon/PokemonList.tsx -----
import { useEffect, useState } from 'react';
import { useAppDispatch, useAppSelector } from '../../app/hooks';
import type { RootState, AppDispatch } from '../../app/store';
import { fetchPokemonList } from './pokemonSlice';
import { useNavigate } from 'react-router-dom';
import {
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Paper,
    TablePagination,
    CircularProgress,
    Typography
} from '@mui/material';

const PokemonList: React.FC = () => {
    const dispatch = useAppDispatch<AppDispatch>();
    const navigate = useNavigate();
    const { list, listStatus, listError } = useAppSelector((state: RootState) => state.pokemon);

    // Pagination state
    const [page, setPage] = useState(0);
    const [rowsPerPage, setRowsPerPage] = useState(10);

    useEffect(() => {
        // Fetch list using current page and rowsPerPage
        dispatch(fetchPokemonList({ limit: rowsPerPage, offset: page * rowsPerPage }));
    }, [dispatch, page, rowsPerPage]);

    const handleChangePage = (event: unknown, newPage: number) => {
        setPage(newPage);
    };

    const handleChangeRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
        setRowsPerPage(parseInt(event.target.value, 10));
        setPage(0);
    };

    return (
        <Paper sx={{ width: '100%', overflow: 'hidden', p: 2 }}>
            <Typography variant="h4" gutterBottom>
                Pok√©mon List
            </Typography>
            {listStatus === 'loading' ? (
                <CircularProgress />
            ) : listStatus === 'failed' ? (
                <Typography color="error">{listError}</Typography>
            ) : (
                <>
                    <TableContainer>
                        <Table>
                            <TableHead>
                                <TableRow>
                                    <TableCell>ID</TableCell>
                                    <TableCell>Name</TableCell>
                                    <TableCell>Height</TableCell>
                                    <TableCell>Weight</TableCell>
                                </TableRow>
                            </TableHead>
                            <TableBody>
                                {list.map(pokemon => (
                                    <TableRow
                                        key={pokemon.id}
                                        hover
                                        sx={{ cursor: 'pointer' }}
                                        onClick={() => navigate(`/item/${pokemon.id}`)}
                                    >
                                        <TableCell>{pokemon.id}</TableCell>
                                        <TableCell>{pokemon.name}</TableCell>
                                        <TableCell>{pokemon.height}</TableCell>
                                        <TableCell>{pokemon.weight}</TableCell>
                                    </TableRow>
                                ))}
                            </TableBody>
                        </Table>
                    </TableContainer>
                    <TablePagination
                        component="div"
                        count={1000}  // Ideally, fetch and store the total count from the API.
                        page={page}
                        onPageChange={handleChangePage}
                        rowsPerPage={rowsPerPage}
                        onRowsPerPageChange={handleChangeRowsPerPage}
                    />
                </>
            )}
        </Paper>
    );
};

export default PokemonList;
----- End of file: ./src/features/pokemon/PokemonList.tsx -----

----- Start of file: ./src/features/pokemon/pokemonRepository.ts -----
// Define interfaces for summary and detailed data
export interface PokemonSummary {
    id: number;
    name: string;
    height: number;
    weight: number;
    sprite_url: string;
  }
  
  export interface PokemonDetail extends PokemonSummary {
    stats: { stat_name: string; base_stat: number; effort: number }[];
    types: string[];
  }
  
  const API_BASE_URL = '/api'; // relative URL (assumes same origin)
  
  export const fetchPokemons = async (limit: number, offset: number): Promise<PokemonSummary[]> => {
    const response = await fetch(`${API_BASE_URL}/items?limit=${limit}&offset=${offset}`);
    if (!response.ok) {
      throw new Error('Failed to fetch pokemons');
    }
    return response.json();
  };
  
  export const fetchPokemonById = async (id: number): Promise<PokemonDetail> => {
    const response = await fetch(`${API_BASE_URL}/item/${id}`);
    if (!response.ok) {
      throw new Error('Failed to fetch pokemon detail');
    }
    return response.json();
  };
  ----- End of file: ./src/features/pokemon/pokemonRepository.ts -----

----- Start of file: ./src/features/pokemon/pokemonSlice.ts -----
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import type { PokemonSummary, PokemonDetail } from './pokemonRepository';
import { fetchPokemons, fetchPokemonById } from './pokemonRepository';

interface PokemonState {
    list: PokemonSummary[];
    listStatus: 'idle' | 'loading' | 'succeeded' | 'failed';
    listError: string | null;
    detail: { [id: number]: PokemonDetail | undefined };
    detailStatus: { [id: number]: 'idle' | 'loading' | 'succeeded' | 'failed' };
    detailError: { [id: number]: string | null };
}

const initialState: PokemonState = {
    list: [],
    listStatus: 'idle',
    listError: null,
    detail: {},
    detailStatus: {},
    detailError: {}
};

export const fetchPokemonList = createAsyncThunk(
    'pokemon/fetchList',
    async ({ limit, offset }: { limit: number; offset: number }) => {
        return await fetchPokemons(limit, offset);
    }
);

export const fetchPokemonDetail = createAsyncThunk(
    'pokemon/fetchDetail',
    async (id: number) => {
        return await fetchPokemonById(id);
    }
);

const pokemonSlice = createSlice({
    name: 'pokemon',
    initialState,
    reducers: {},
    extraReducers: builder => {
        // List
        builder.addCase(fetchPokemonList.pending, state => {
            state.listStatus = 'loading';
        });
        builder.addCase(fetchPokemonList.fulfilled, (state, action) => {
            state.listStatus = 'succeeded';
            state.list = action.payload;
        });
        builder.addCase(fetchPokemonList.rejected, (state, action) => {
            state.listStatus = 'failed';
            state.listError = action.error.message || 'Failed to fetch';
        });
        // Detail
        builder.addCase(fetchPokemonDetail.pending, (state, action) => {
            state.detailStatus[action.meta.arg] = 'loading';
        });
        builder.addCase(fetchPokemonDetail.fulfilled, (state, action) => {
            state.detailStatus[action.payload.id] = 'succeeded';
            state.detail[action.payload.id] = action.payload;
        });
        builder.addCase(fetchPokemonDetail.rejected, (state, action) => {
            state.detailStatus[action.meta.arg] = 'failed';
            state.detailError[action.meta.arg] = action.error.message || 'Failed to fetch detail';
        });
    }
});

export default pokemonSlice.reducer;
----- End of file: ./src/features/pokemon/pokemonSlice.ts -----

----- Start of file: ./src/index.css -----
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}
----- End of file: ./src/index.css -----

----- Start of file: ./src/main.tsx -----
import React from "react"
import { createRoot } from "react-dom/client"
import { Provider } from "react-redux"
import App from "./App"
import { store } from "./app/store"
import "./index.css"

const container = document.getElementById("root")

if (container) {
  const root = createRoot(container)

  root.render(
    <React.StrictMode>
      <Provider store={store}>
        <App />
      </Provider>
    </React.StrictMode>,
  )
} else {
  throw new Error(
    "Root element with ID 'root' was not found in the document. Ensure there is a corresponding HTML element with the ID 'root' in your HTML file.",
  )
}
----- End of file: ./src/main.tsx -----

----- Start of file: ./src/setupTests.ts -----
import "@testing-library/jest-dom/vitest"
----- End of file: ./src/setupTests.ts -----

----- Start of file: ./src/vite-env.d.ts -----
/// <reference types="vite/client" />
----- End of file: ./src/vite-env.d.ts -----

----- Start of file: ./tsconfig.json -----
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": [
      "DOM",
      "DOM.Iterable",
      "ESNext"
    ],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "types": [
      "vitest/globals"
    ]
  },
  "include": [
    "src",
    "vite.config.ts"
  ],
  "references": [
    {
      "path": "./tsconfig.node.json"
    }
  ]
}----- End of file: ./tsconfig.json -----

----- Start of file: ./tsconfig.node.json -----
{
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
----- End of file: ./tsconfig.node.json -----

----- Start of file: ./vite.config.ts -----
import { defineConfig } from "vitest/config"
import react from "@vitejs/plugin-react"

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    open: true,
  },
  test: {
    globals: true,
    environment: "jsdom",
    setupFiles: "src/setupTests",
    mockReset: true,
  },
})
----- End of file: ./vite.config.ts -----

